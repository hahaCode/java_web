##JUC高并发编程

###1.JUC概述
#### 1.1 什么是JUC
     JUC是java.util.concurrent工具包的简称
#### 1.2 进程与线程
     进程是系统进行资源分配和调度的基本单位, 是操作系统结构的基础
     线程是操作系统能够进行运算调度的最小单位. 它被包含在进程中, 是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流, 一个进程中可以并发多个线程, 每条线程并行执行不同任务

     小结：进程指在系统中正在运行的一个应用程序, 程序一旦运行就是进程, 进程是资源分配的最小单位; 线程是系统分配处理器时间资源的基本单位, 或者说进程之内独立执行的一个单元执行流, 线程是程序执行的最小单位

###2.Lock接口
#### 2.1 Synchronized
     虽然可以使用synchronied来定义方法，但是synchronized并不属于方法定义的一部分，因此， synchronized不能被继承，如果在父类中的某个方法使用了synchronied
     关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个中加上synchronized关键字才可以。当然，可以在子类的方法中
     调用父类这样虽然子类的方法不是同步的，但子类调用了父类的同步方法，子类的方法也相当于同步了

#### 2.2 多线程编程步骤
     + 创建资源类，创建属性和操作方法
     + 在资源类操作方法中，进行 判断，干活，通知
     + 创建多线程调用资源类的方法
     + 防止虚假唤醒的问题

#### 2.3 Lock和Synchronized区别
     + Lock不是Jave语言内置的, synchronized是java语言的关键字，是内置特性，Lock是一个类，通过这个类可以实现同步访问
     + Lock和sychronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchrozied方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁
       的占用；而Lock则必须手动释放锁，如果没有主动释放锁，就可能导致死锁现象
     + synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而lock在发生异常时，如果没有主动释放锁，很可能会造成死锁现象，因此使用lock需要在finally
       块中释放锁
     + lock可以让等待锁的线程相应中断，但synchronized却不行，使用synchronized却无法做到
     + lock可以提高多个线程进行读操作的效率
     + 性能上来看，如果有大量线程同时竞争，此时lock的性能要远大于synchronized

###3.多线程锁
#### 3.1 Synchronized中的锁三种形式
     + 对于普通同步方法, 锁是当前对象的实例
     + 对于静态同步方法, 锁是当前类的Class对象
     + 对于同步方法块, 锁是synchronized括号里配置的对象
#### 3.2 公平锁和非公平锁

#### 3.3 可重入锁(递归锁)

#### 3.4 死锁

###4. Callable接口
#### 4.1 创建线程的多种方式
     + 继承Thread类
     + 实现Runable接口(可以返回线程完成时返回的结果)
     + Callable接口
     + 线程池方式

###5.JUC中强大的辅助类
#### 5.1 减少计数CountDownLatch


###6. 读写锁
####6.2 通俗理解读写锁
        一个资源可以被多个读线程访问, 或者可以被一个写线程访问, 但是不能同时存在读写线程, 读写互斥, 读读共享
####6.3 读写锁的缺点
    + 造成锁饥饿, 一直读, 没有写操作
####6.4 锁降级
    + 就是可以在写操作的时候进行读操作 (写锁降级为读锁)
    + 步骤：获取写锁 ---> 获取读锁 ---> 释放写锁  ---> 释放读锁

###7. blockingqueue
####7.1 阻塞队列
    + 当队列是空的, 从队列中获取元素的操作将会被阻塞
    + 当队列是满的, 从队列中添加元素的操作将会被阻塞

###8. 线程池
####8.1 什么是线程池
        线程池做的工作主要是控制运行的线程数量, 处理过程中将任务放入队列, 然后在线程创建后启动这些任务, 如果线程数量超过了最大数量, 超出数量的线程排队等候
        其他线程执行完毕, 再从队列中取出任务来执行
####8.2 线程池的优势
    + 降低资源消耗
    + 提高相应速度
    + 提高线程的可管理性

     

